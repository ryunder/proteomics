---
title: "R Notebook"
output: html_notebook
---

#Introduction
I am analyzing IP/MS data generated by Johan on 10-06-2018. The experiment is designed to investigate protein accumulation in response to heat shock/stress in a variety of genetic backgrounds.

Backgrounds include: WT, pals-22, cul-6, pals-22; cul-6

I will be following the same analysis as I previously used for IP/MS data produced by Johan (circa 08-20-2018). This utilizes the DEP package obtained via bioconductor. Additionally, it makes use of the dplyr package obtained using the `install.packages()` function.

#Setup
##Load required libraries
```{r}
library(DEP)
library(dplyr)
```

##Import data
Note: there were issues encountered when attempting to import the excel file directly. I believe the error is related to the encoding (e.g. UTF-8) of the original file or possibly due to something specific to the xlsx filetype. I solved this issue by saving a copy of the original file in the csv filetype.
```{r}
file <- "2018_10_06_Panek_maxquant.csv"
maxq_orig <- read.csv(file, stringsAsFactors = F)
dim(maxq_orig)
head(maxq_orig)
```
We have succesfully loaded the data, and the dimensions are consistent with the original excel file. We will next organize the data.

##Organize data
Next step is to organize the data. According to the previous section, we have over 350 columns of data! Wow... We don't need all of the columns for the analysis, but we would like to preserve them. We will store the required columns into a new data frame. Required columns are essentially the protein identification columns and the data columns.

```{r}
colnames(maxq_orig)
```
Based on the column names, we certainly want the protein IDs (col 1 and 2) the gene names (col 7) and the FASTA headers (col 8), although that one I think is optional. To obtain the LFQ columns (the data columns for this particular analysis) we can manually select them via column numbers or use a fancy function. In this instance we use two functions. First we select the identifier columns using column numbers, then we use `cbind()` to combine the dataframes (if we don't use `cbind()` then we will simply overwrite our `maxq` object), and we use `grepl()` to select columns that start with "LFQ". (What `grepl()` really does is return a boolean (TRUE or FALSE) vector for all columns. With TRUE returned if the column begins with "LFQ" and FALSE if it does not. This vector is then what determine which columns will be subsetted (TRUE) or ignored (FALSE).) 

```{r}
data <- maxq_orig[,c(1,2,7,8)]
data <- cbind(data, maxq_orig[,grepl("LFQ", colnames(maxq_orig))])
dim(data)
colnames(data)
head(data)
```
Visually inspection confirms we have all data columns and identifier columns.

```{r}
colnames(data) <- gsub("LFQ.intensity.", "", colnames(data))
colnames(data) <- gsub("Heat.Shock", "HS", colnames(data))
colnames(data) <- gsub("Total_extract", "TE", colnames(data))
colnames(data) <- gsub("TUBE.IP", "IP", colnames(data))
colnames(data)
```


#Data preprocessing
This section checks for duplicates and generates unique names for every sample.
```{r}
data$Protein.IDs %>% duplicated() %>% any()
data$Gene.names %>% duplicated() %>% any()
colnames(data) %>% duplicated() %>% any()

data %>% group_by(Protein.IDs) %>% summarise(frequency = n()) %>%
  arrange(desc(frequency)) %>% filter(frequency > 1)
data %>% group_by(Gene.names) %>% summarise(frequency = n()) %>%
  arrange(desc(frequency)) %>% filter(frequency > 1)

data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
data_unique$name %>% duplicated() %>% any()
```

The first FALSE means no duplicated Protein IDs which is good, next, TRUE means there are duplicated genes, which is okay. Third, FALSE, indicates no duplicate column names which is required, and the fourth, FALSE, means that our unique identifiers are all unique. In this particular case, unique identifiers will just be the Protein IDs since they were unique anyways, but it is a required step because later on a function will look for that column.

The previous analysis included some sample rows that were nonsensical and had to be removed. Here that is not the case, and I think that is due to Johan removing the weird rows in excel prior to providing the data to me.

##Make experiment data frame
We need to generate a couple of data objects to assign experimental design classifiers to the data. First we will make a data frame of three columns, "label", "condition", and "replicate". These columns *MUST* be named using this convention in this order. label - individual label for each sample. condition - genotype or treatment. replicate - replicate number of sample.

The second object to make is a numeric vector containing the column numbers associated with the data columns. That is: if you look at `data_unique` what are the column numbers of the columns containing the data. These numbers will match the rows of our `maxq_ExpDesign` data frame to their respective data column, so this step is crucial to get correct.

We will also make the sample labels easier to read.

Sample data exists in columns 5:40
```{r}
#select names of columns
maxq_labels <- colnames(data)[5:40]

#extract sample name, but lose the replicate number. this is the condition 
maxq_condition <- substr(maxq_labels, 1, (nchar(maxq_labels)-2))

#vector identifiying replicates, 12 unique conditions 
maxq_replicate <- c(rep(1:3,12))

#Generate the experimental design object
maxq_ExpDesign <- data.frame("label"=maxq_labels, "condition"=maxq_condition,
                             "replicate"=maxq_replicate, stringsAsFactors = F)
maxq_columns <- 5:40

maxq_ExpDesign
maxq_columns
```

##Generate Summaraized Experiment object
`make_se()` is a function from the DEP library. It will take our data table and match it to the experiment data we just generated. The product is a SummarizedExperiment object.
```{r}
data_se <- make_se(data_unique, maxq_columns, maxq_ExpDesign)
data_se
```

#Visualize data summary
A bargraph depicting protein identification overlap between samples. We can see that most proteins are identified in all samples, with a large number of proteins only being identified in a single sample. Additionally, we can see a small number of proteins are not identified in any sample.
```{r}
plot_frequency(data_se)
```

##Filter data
We want to remove proteins with no data for sure, and we probably are not interested in proteins that are only seen in a single sample. I will graph two different thresholds just to give an idea of the diferences in the number of proteins that are filtered.
```{r}
#identified in all replicates of at least one condition
data_filt <- filter_missval(data_se, thr = 0) 
#identified in at least 2 replicates in at least one condition
data_filt2 <- filter_missval(data_se, thr = 1) 

par(mfrow = c(1,2), cex=0.5, cex.lab=0.5, cex.sub=0.5, cex.axis=0.5)
#Total number of proteins per sample
plot_numbers(data_filt)
plot_numbers(data_filt2)  
#barplot showing proteins identified in a multiple samples
plot_coverage(data_filt)
plot_coverage(data_filt2)
```

We will continue the analysis using `data_filt`, that is eliminate proteins that are not found in each sample of at least one condition. It is relatively simple to return to this step and choose a different threshold later.

#Normalization
Normalize by variance stabilizing transformation (vsn). This is similar to the `voom()` function that we use in RNA-seq analysis, in that we are taking samples whose variance depends on the mean and applying vsn so that the sampling variance will be approximately constant.
```{r}
data_norm <- normalize_vsn(data_filt)
plot_normalization(data_filt, data_norm)
```

I am not certain I can see a difference between the two plots.

##Impute data for missing values
This is a tricky step which I am not completely clear on. From what I do undestand, we have two main classes of missing data - missing at random (MAR) and missing not at random (MNAR). Examples given are: MAR- "if proteins are quantified in some replicates but not others", MNAR-"proteins are below detection limit in specific samples". Our goal in these next steps is to fill in the NA values with likely values. If values are MAR, then we use data in other replicates to "guess" a likely value. If data is MNAR, then  a small value is randomly assigned based on a normal distribution. [See here](https://bioconductor.org/packages/release/bioc/vignettes/DEP/inst/doc/MissingValues.html) for a more detailed look at this step.

##Check for missing values
The first step is too look at the missing values in a heatmap and try to determine if we are MAR or MNAR.
```{r fig.height=11}
plot_missval(data_filt)
```

The heatmap shows that missing values missing values are generally clustered. It is comforting that the clustering grouped the replicates together, particularly the Total EXtact vs TUBE IP, exactly how we'd expect. Our next check will be to look and see if missing values are enriched for lower intensity (low signal) proteins.
```{r}
plot_detect(data_filt)
```
Missing values are absolutely clustered at low signal proteins. This is highly indicative that many missing values are due to being under the detection threshold. 

Based on the DEP vignette, this instructs us which statistical method should be used to impute values. We will use "MinProb" based on the vignette which will randomly select a value from a Gaussian distribution centered around a minimal value. Essentially, because we think that these missing values are generally due to being below detection levels, we can fill in these values with random small values. 

##Impute Data
```{r}
data_imp <- impute(data_norm, fun = "MinProb")
plot_imputation(data_norm, data_imp)
```

This graph shows us now that we've added many low intensity values to the data table.

#Differential enrichment analysis
Generating a linear model and performing statistcal analysis using the limma package. First we will check the condition names so that we can imput the proper names of samples in order to set up our contrasts.

```{r}
maxq_ExpDesign
```

##Setup Contrasts
Previous analysis was more straightforward. We tested all samples against the control "N2" sample. In this case, we essentially have two seperate experiments, that'd be thte total extract and the TUBE IP samples. Additionally, each of those groups have N2 control and N2 heatshock samples.
```{r}
#Manually input contrasts
data_diff <- test_diff(data_imp, type = "manual", 
                       test = c("IP_N2_HS_vs_IP_N2_Control", "IP_Jy1_HS_vs_IP_N2_HS",
                                "IP_Cul6_HS_vs_IP_N2_HS", "IP_Jy1_Cul6_HS_vs_IP_N2_HS",
                                "TE_Jy1_HS_vs_TE_N2_HS", "TE_Cul6_HS_vs_TE_N2_HS",
                                "TE_Jy1_Cul6_HS_vs_TE_N2_HS", "TE_Jy1_Jy11_HS_vs_TE_N2_HS"))
```

##Significance testing
The previous step sets up the contrasts, while this step sets the parameters for what will be called "differentially enriched". Adjust the lfc and p value (alpha) settings as you see fit.
```{r}
lfc = 1
alpha = 0.05

dep <- add_rejections(data_diff, alpha = alpha, lfc = lfc)
```

#Visualization of Results

##PCA plot
Check for clustering. Quality of data can be assesed here.
```{r fig.height=6, fig.width=10}
plot_pca(dep, x = 1, y = 2, n = 500, point_size = 4)
```

##Correlation Matrix
```{r}
plot_cor(dep, significant = TRUE, lower = 0, upper = 1, pal = "Reds")
```

##HEATMAPS

```{r fig.height=11}
plot_heatmap(dep, type = "centered", kmeans = TRUE, 
             k = 6, col_limit = 4, show_row_names = FALSE,
             indicate = c("condition", "replicate"))
```


```{r fig.height=11}
plot_heatmap(dep, type = "contrast", kmeans = TRUE, 
             k = 6, col_limit = 10, show_row_names = FALSE)
```

